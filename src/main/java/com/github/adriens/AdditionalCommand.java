package com.github.adriens;


import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import schemacrawler.schema.Column;
import schemacrawler.schema.Property;
import schemacrawler.schema.Schema;
import schemacrawler.schema.Table;
import schemacrawler.tools.executable.BaseSchemaCrawlerCommand;
import schemacrawler.tools.lint.*;
import schemacrawler.tools.lint.executable.LintOptions;
import schemacrawler.tools.lint.executable.LintOptionsBuilder;

import java.io.FileWriter;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * SchemaCrawler command plug-in.
 *
 * @see <a href="https://www.schemacrawler.com">SchemaCrawler</a>
 * @author Automatically generated by SchemaCrawler 16.9.4
 */
public class AdditionalCommand extends BaseSchemaCrawlerCommand<AdditionalOptions> {

  private static final Logger LOGGER = Logger.getLogger(AdditionalCommand.class.getName());

  static final String COMMAND = "csv";
  private String lintsFilename;
  private static final String DEFAULT_LINTS_FILENAME_PREFIX = "schemacrawler-lints";
  private static final String DEFAULT_LINTS_FILENAME_PREFIX_ROWCOUNT = "schemacrawler-tables";
  private static final String DEFAULT_LINTS_FILENAME_PREFIX_COLUMNS = "schemacrawler-columns";
  private static final String NEW_LINE_SEPARATOR = "\n";
  private static final Object[] FILE_HEADER = {
          "sclint-dbenv",
          "sclint-dbid",
          "sclint-catalogName",
          "sclint-runid",
          "sclint-hitid",
          "sclint-linterId",
          "sclint-severity",
          "sclint-objectName",
          "sclint-message",
          "sclint-value" };
  private static final Object[] FILE_HEADER_TABLE_ROW_COUNT = {
          "sclint-dbenv",
          "sclint-dbid",
          "sclint-catalogName",
          "sclint-runid",
          "sclint-hitid",
          "sclint-tableFullName",
          "sclint-tableName",
          "sclint-schemaName",
          "sclint-tableType",
          "sclint-tableNbColumns",
          "sclint-tableNbRows" };
  private static final Object[] FILE_HEADER_TABLE_COLUMNS = {
          "sclint-dbenv",
          "sclint-dbid",
          "sclint-catalogName",
          "sclint-runid",
          "sclint-schema-name",
          "sclint-table-name",
          "sclint-table-fullname",
          "sclint-table-remarks",
          "sclint-table-type",
          "sclint-column-short-name",
          "sclint-column-name",
          "sclint-column-fullname",
          "sclint-column-ordinal-position",
          "sclint-column-remarks",
          "sclint-column-default-value",
          "sclint-column-size",
          "sclint-column-type-typename",
          "sclint-column-type-fullname",
          "sclint-column-type-name",
          "sclint-column-type-java-sqltype-group" };

  protected AdditionalCommand()
  {
    super(COMMAND);
  }


  @Override
  public void execute() throws Exception {
    checkCatalog();

    // TODO: Possibly process command-line options, which are available
    // in additionalConfiguration
    LOGGER.log(Level.SEVERE, "command options: " + commandOptions.toString());
    LOGGER.log(Level.SEVERE, "command :" + commandOptions.getProperties().get("sun.java.command"));


    // get and set dbid
    String dbId = commandOptions.getDbId();
    LOGGER.log(Level.INFO, String.format("Got input dbId : <%s>", dbId));

    // get and set dbenv
    // dbenv
    String dbEnv = commandOptions.getDbEnv()
            .toLowerCase();
    LOGGER.log(Level.INFO, String.format("Got input dbEnv : <%s>", dbEnv));

    String dbCatalogName = getDbCatalogName();
    LOGGER.log(Level.INFO, String.format("DATABASE NAME : <%s>", dbCatalogName));

    String runId = catalog.getCrawlInfo().getRunId();


//    try
//    {
//      generateLintsCsv(dbEnv, dbId, runId, dbCatalogName);
//    }
//    catch (Exception ex)
//    {
//      LOGGER.log(Level.SEVERE,
//              "Was not able to perform lint operation : "
//                      + ex.getMessage());
//      throw ex;
//    }


    try{
      generateTableRowCountCsv(dbEnv, dbId, runId);
    } catch (Exception ex) {
      LOGGER.log(Level.SEVERE,
              "Was not able to perform table row count operation : "
                      + ex.getMessage());
      throw ex;
    }

    try
    {
      generateTableColumnsCsv(dbEnv, dbId, runId);
    }
    catch (Exception ex)
    {
      LOGGER.log(Level.SEVERE,
              "Was not able to perform table columns reporting : "
                      + ex.getMessage());
      throw ex;
    }
  }

  private String getDbCatalogName()
  {
    String dbCatalogName = "";
    final Map<String, String> serverInfoMap = new HashMap<>();
    for (final Property serverInfoProperty: catalog.getDatabaseInfo()
            .getServerInfo())
    {
      serverInfoMap.put(serverInfoProperty.getName(),
              serverInfoProperty.getValue().toString());
    }
    LOGGER.info("MAP : " + serverInfoMap.toString());

    if (serverInfoMap.containsKey("GLOBAL_NAME"))
    {
      // Oracle GLOBAL_NAME
      dbCatalogName = serverInfoMap.get("GLOBAL_NAME");
    }
    else if (serverInfoMap.containsKey("current_database"))
    {
      // PostgreSQL current_database
      dbCatalogName = serverInfoMap.get("current_database");
    }
    else if (serverInfoMap.containsKey("ServerName"))
    {
      // Microsoft SQL Server ServerName
      dbCatalogName = serverInfoMap.get("ServerName");
    }
    else if (serverInfoMap.containsKey("CATALOG_NAME"))
    {
      // HyperSQL (HSQLDB) CATALOG_NAME
      dbCatalogName = serverInfoMap.get("CATALOG_NAME");
    }

    return dbCatalogName;
  }

  public String getLintsFilename()
  {
    return this.lintsFilename;
  }

  public void setLintsFilename(String aLintsFilename)
  {
    this.lintsFilename = aLintsFilename;
  }


  private void generateLintsCsv(String aDbEnv,
                                String aDbId,
                                String aRunId,
                                String aDbCatalogName)
          throws Exception
  {
    String command;

    // Options
    final LintOptions lintOptions = LintOptionsBuilder.builder()
            .fromConfig(co).toOptions();
    // setLintsFilename(additionalConfiguration.getStringValue("outputfile",
    // DEFAULT_LINTS_FILENAME));

    CSVPrinter csvFilePrinter;
    FileWriter fileWriter;
    CSVFormat csvFileFormat = CSVFormat.DEFAULT
            .withRecordSeparator(NEW_LINE_SEPARATOR);


    setLintsFilename(String
            .format("%s-%s.csv", DEFAULT_LINTS_FILENAME_PREFIX, aRunId));
    LOGGER.log(Level.INFO,
            String.format("Generating lints for run <%s> ...", aRunId));
    final LinterConfigs linterConfigs = LintUtility
            .readLinterConfigs(lintOptions, getAdditionalConfiguration());
    final Linters linters = new Linters(linterConfigs, true);
    linters.lint(catalog, connection);

    final LintCollector lintCollector = linters.getCollector();

    // feed the csv
    fileWriter = new FileWriter(getLintsFilename());

    // initialize CSVPrinter object
    csvFilePrinter = new CSVPrinter(fileWriter, csvFileFormat);

    // Create CSV file header
    csvFilePrinter.printRecord(FILE_HEADER);
    LOGGER.log(Level.CONFIG, lintCollector.getLints().size()+"");
    for (Lint aLint : lintCollector.getLints()) {

      List lintDataRecord = new ArrayList();
      lintDataRecord.add(aDbEnv);
      lintDataRecord.add(aDbId);
      lintDataRecord.add(aDbCatalogName);
      lintDataRecord.add(aRunId);
      lintDataRecord.add(aLint.getLintId().toString());

      lintDataRecord.add(aLint.getLinterId());
      lintDataRecord.add(aLint.getSeverity().toString().toUpperCase());
      lintDataRecord.add(aLint.getObjectName());
      lintDataRecord.add(aLint.getMessage());
      lintDataRecord.add(aLint.getValueAsString());

      LOGGER.log(Level.CONFIG, aLint.toString());
      csvFilePrinter.printRecord(lintDataRecord);
    }
    fileWriter.flush();
    fileWriter.close();
    LOGGER.log(Level.CONFIG,
            String.format("Lint runid : <%s> generated.", aRunId));

  }

  public void generateTableRowCountCsv(String aDbEnv,
                                       String aDbId,
                                       String aRunId)
          throws Exception
  {
    LOGGER.log(Level.INFO, "Counting rows for each table ...");
    String rowCountFilename = String
            .format("%s-%s-.csv", DEFAULT_LINTS_FILENAME_PREFIX_ROWCOUNT, aRunId);
    LOGGER.log(Level.INFO,
            "Putting table row count datas in <" + rowCountFilename + ">");

    CSVPrinter csvFilePrinter;
    FileWriter fileWriter;
    CSVFormat csvFileFormat = CSVFormat.DEFAULT
            .withRecordSeparator(NEW_LINE_SEPARATOR);

    fileWriter = new FileWriter(rowCountFilename);

    // initialize CSVPrinter object
    csvFilePrinter = new CSVPrinter(fileWriter, csvFileFormat);
    // Create CSV file header
    csvFilePrinter.printRecord(FILE_HEADER_TABLE_ROW_COUNT);
    for (final Schema schema: catalog.getSchemas())
    {
      for (final Table table: catalog.getTables(schema))
      {
        // for each table, count the number of rows
        String sql = "select count(1) from " + table.getFullName();
        Statement stmt = null;
        try
        {
          stmt = connection.createStatement();
          ResultSet rs = stmt.executeQuery(sql);
          String dbCatalogName = getDbCatalogName();
          while (rs.next())
          {
            int nbRows = rs.getInt(1);
            List lintDataRecord = new ArrayList();
            // runtime datas

            lintDataRecord.add(aDbEnv);
            lintDataRecord.add(aDbId);
            lintDataRecord.add(dbCatalogName);
            lintDataRecord.add(aRunId);
            lintDataRecord.add(UUID.randomUUID().toString());

            // table centric datas
            LOGGER.log(Level.INFO,
                    "Found <" + nbRows + "> rows in <" + table.getFullName()
                            + ">");
            String tableFullName = table.getFullName();
            String tableName = table.getName();
            String tableRemarks = table.getRemarks();
            String tableSchemaName = table.getSchema().getName();
            String tableType = table.getTableType().getTableType();
            int tableNbColumns = table.getColumns().size();

            lintDataRecord.add(tableFullName);
            lintDataRecord.add(tableName);
            lintDataRecord.add(tableSchemaName);
            lintDataRecord.add(tableType);
            lintDataRecord.add(tableNbColumns);
            lintDataRecord.add(nbRows + "");

            csvFilePrinter.printRecord(lintDataRecord);

          }
        }
        catch (SQLException ex)
        {
          LOGGER.log(Level.SEVERE,
                  "Not able to count rows : " + ex.getMessage());
        }
        finally
        {
          if (stmt != null)
          {
            stmt.close();
          }
        }
      }
    }
    fileWriter.flush();
    fileWriter.close();
  }

  public void generateTableColumnsCsv(String aDbEnv,
                                      String aDbId,
                                      String aRunId)
          throws Exception
  {
    LOGGER.log(Level.INFO, "Dumping each column of each table ...");
    String rowCountFilename = String
            .format("%s-%s-.csv", DEFAULT_LINTS_FILENAME_PREFIX_COLUMNS, aRunId);
    LOGGER.log(Level.INFO,
            "Putting table row count datas in <" + rowCountFilename + ">");

    CSVPrinter csvFilePrinter;
    FileWriter fileWriter;
    CSVFormat csvFileFormat = CSVFormat.DEFAULT
            .withRecordSeparator(NEW_LINE_SEPARATOR);

    fileWriter = new FileWriter(rowCountFilename);

    // initialize CSVPrinter object
    csvFilePrinter = new CSVPrinter(fileWriter, csvFileFormat);
    // Create CSV file header
    csvFilePrinter.printRecord(FILE_HEADER_TABLE_COLUMNS);
    for (final Schema schema: catalog.getSchemas())
    {
      for (final Table table: catalog.getTables(schema))
      {
        // for each table, count the number of rows
        String lSchema = table.getSchema().getName();
        String lTableName = table.getName();
        String lTableFullName = table.getFullName();
        String lTableRemarks = table.getRemarks();
        String lTableType = table.getTableType().getTableType();
        String dbCatalogName = getDbCatalogName();
        // fetch columns
        for (final Column column: table.getColumns())
        {
          // names
          column.getShortName();
          column.getName();
          column.getFullName();
          column.getOrdinalPosition();
          column.getRemarks();

          // type centric
          column.getDefaultValue();
          column.getSize();

          // type centric datas
          // column.getColumnDataType().getBaseType().getDatabaseSpecificTypeName();
          // column.getColumnDataType().getBaseType().getFullName().toString();
          // column.getColumnDataType().getBaseType().getJavaSqlType().getName();
          // column.getColumnDataType().getBaseType().getJavaSqlType().getJavaSqlTypeGroup().toString();
          List lintDataRecord = new ArrayList();
          // runtime datas
          lintDataRecord.add(aDbEnv);
          lintDataRecord.add(aDbId);
          lintDataRecord.add(dbCatalogName);
          lintDataRecord.add(aRunId);

          lintDataRecord.add(table.getSchema().getName());
          lintDataRecord.add(table.getName());
          lintDataRecord.add(table.getFullName());
          lintDataRecord.add(table.getRemarks());
          lintDataRecord.add(table.getTableType().toString());
          lintDataRecord.add(column.getShortName());
          lintDataRecord.add(column.getName());
          lintDataRecord.add(column.getFullName());
          lintDataRecord.add(column.getOrdinalPosition());
          lintDataRecord.add(column.getRemarks());
          lintDataRecord.add(column.getDefaultValue());
          lintDataRecord.add(column.getSize());
          lintDataRecord.add(column.getType().getName());
          lintDataRecord.add(column.getType().getFullName());
          lintDataRecord.add(column.getType().getName());
          lintDataRecord.add(column.getType().getJavaSqlType().getName());
          lintDataRecord.add(column.getType().getJavaSqlType()
                  .getJavaSqlTypeGroup().toString());

          csvFilePrinter.printRecord(lintDataRecord);

        }

        fileWriter.flush();
      }
    }
    fileWriter.flush();
    fileWriter.close();
  }
}
